clear screen;
drop TABLE operations1;
CREATE TABLE operations1(opnum number, operationtype varchar2(20), iptype varchar2(20), optype varchar2(20) );
SELECT * from operations1;

INSERT into operations1 values(1,'conversion','octal','binary');
INSERT into operations1 values(2,'conversion','decimal','binary');
INSERT into operations1 values(3,'conversion','hexa','binary');

INSERT into operations1 values(4,'conversion','binary','octal');
INSERT into operations1 values(5,'conversion','decimal','octal');
INSERT into operations1 values(6,'conversion','hexa','octal');

INSERT into operations1 values(7,'conversion','binary','decimal');
INSERT into operations1 values(8,'conversion','octal','decimal');
INSERT into operations1 values(9,'conversion','hexa','decimal');

INSERT into operations1 values(10,'conversion','binary','hexa');
INSERT into operations1 values(11,'conversion','octal','hexa');
INSERT into operations1 values(12,'conversion','decimal','hexa');

SELECT * from operations1;

commit;

SET VERIFY OFF;
SET SERVEROUTPUT ON;

DECLARE
  A operations1.opnum%TYPE;
  B operations1.operationtype%TYPE;
  C operations1.iptype%TYPE;
  D operations1.optype%TYPE;
  
BEGIN
    DBMS_OUTPUT.PUT_LINE('Operation list :');
	DBMS_OUTPUT.PUT_LINE('Sl No.' || '     ' || 'Operation Type' || '     ' || 'Input type' || '     ' || 'Output type');
	FOR R IN (SELECT * FROM operations1) LOOP
		A := R.opnum;
        B := R.operationtype;
        C := R.iptype;
        D := R.optype;
		DBMS_OUTPUT.PUT_LINE(A || '           ' || B || '           ' || C || '           ' || D);
	END LOOP;
END;
/

SET VERIFY OFF;
SET SERVEROUTPUT ON;
CREATE OR REPLACE PACKAGE mypack AS

	FUNCTION DecimalToBinary(A1 IN NUMBER)
	RETURN NUMBER;
	FUNCTION DecimalToOctal(B1 IN NUMBER)
	RETURN NUMBER;
	FUNCTION DecimalToHexa(C1 IN NUMBER)
	RETURN NUMBER;
	FUNCTION BinaryToDecimal(binval in char)
	RETURN NUMBER;
	FUNCTION OctalToDecimal(binval in char)
	RETURN NUMBER;
	FUNCTION HexaToDecimal(binval in char)
	RETURN NUMBER;
	
END mypack;
/

CREATE OR REPLACE PACKAGE BODY mypack AS

	FUNCTION DecimalToBinary(A1 IN NUMBER)
	RETURN NUMBER
	IS
	ln_unit NUMBER;
    ln_input NUMBER;
    i NUMBER  := 0;
    ln_out NUMBER  := 0;
	BEGIN
		ln_input := A1; 
        WHILE ln_input > 0 LOOP
		    ln_unit := MOD( ln_input, 2 );      
            ln_input := TRUNC(ln_input/2);     
            ln_out := TO_NUMBER(ln_unit * power(10,i) + ln_out);       
            i:= i+1;
        END LOOP;
        RETURN(ln_out);		
	END DecimalToBinary;
	
	
	FUNCTION DecimalToOctal(B1 IN NUMBER)
	RETURN NUMBER
	IS 
	ln_unit NUMBER;
    ln_input NUMBER;
    i NUMBER  := 0;
    ln_out NUMBER  := 0;
	BEGIN
		ln_input := B1; 
        WHILE ln_input > 0 LOOP
		    ln_unit := MOD( ln_input, 8 );      
            ln_input := TRUNC(ln_input/8);     
            ln_out := TO_NUMBER(ln_unit * power(10,i) + ln_out);       
            i:= i+1;
        END LOOP;
        RETURN(ln_out);
	END DecimalToOctal;
	
	
	FUNCTION DecimalToHexa(C1 IN NUMBER)
	RETURN NUMBER
	IS 
	ln_unit NUMBER;
    ln_input NUMBER;
    i NUMBER  := 0;
    ln_out NUMBER  := 0;
	BEGIN
		ln_input := C1; 
        WHILE ln_input > 0 LOOP
		    ln_unit := MOD( ln_input, 16 );      
            ln_input := TRUNC(ln_input/16);     
            ln_out := TO_NUMBER(ln_unit * power(10,i) + ln_out);       
            i:= i+1;
        END LOOP;
        RETURN(ln_out);
	END DecimalToHexa;


FUNCTION BinaryToDecimal(binval in char) RETURN number IS
  i                 number;
  digits            number;
  result            number := 0;
  current_digit     char(1);
  current_digit_dec number;
BEGIN
  digits := length(binval);
  for i in 1..digits loop
     current_digit := SUBSTR(binval, i, 1);
     current_digit_dec := to_number(current_digit);
     result := (result * 2) + current_digit_dec;
  end loop;
  return result;
END BinaryToDecimal;

FUNCTION OctalToDecimal(binval in char) RETURN number IS
  i                 number;
  digits            number;
  result            number := 0;
  current_digit     char(1);
  current_digit_dec number;
BEGIN
  digits := length(binval);
  for i in 1..digits loop
     current_digit := SUBSTR(binval, i, 1);
     current_digit_dec := to_number(current_digit);
     result := (result * 8) + current_digit_dec;
  end loop;
  return result;
END OctalToDecimal;

FUNCTION HexaToDecimal(binval in char) RETURN number IS
  i                 number;
  digits            number;
  result            number := 0;
  current_digit     char(1);
  current_digit_dec number;
BEGIN
  digits := length(binval);
  for i in 1..digits loop
     current_digit := SUBSTR(binval, i, 1);
     current_digit_dec := to_number(current_digit);
     result := (result * 16) + current_digit_dec;
  end loop;
  return result;
END HexaToDecimal;


END mypack;
/

SET SERVEROUTPUT ON;
SET VERIFY OFF;
DECLARE
    test number;
	test2 number;
    X operations1.opnum%TYPE := '&choose_operation_number';  
	negative EXCEPTION;
BEGIN
	IF X < 0 OR X > 12 THEN
		RAISE negative;
	END IF;
	DBMS_OUTPUT.PUT_LINE('Valid number');
	test := mypack.DecimalToBinary(X);
	DBMS_OUTPUT.PUT_LINE(test);
	test := mypack.DecimalToOctal(X);
	DBMS_OUTPUT.PUT_LINE(test);
	test := mypack.DecimalToHexa(X);
	DBMS_OUTPUT.PUT_LINE(test);
	test := mypack.BinaryToDecimal('1101');
	DBMS_OUTPUT.PUT_LINE(test);
	test := mypack.OctalToDecimal('10');
	DBMS_OUTPUT.PUT_LINE(test);
	test := mypack.HexaToDecimal('14');
	DBMS_OUTPUT.PUT_LINE(test);
	
EXCEPTION
	WHEN negative THEN
		DBMS_OUTPUT.PUT_LINE('Ivalid number');
END;
/



